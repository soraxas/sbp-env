

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>planners.rrdtPlanner &mdash; sbp-env 1.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/katex-math.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js"></script>
        <script src="../../_static/katex_autorenderer.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> sbp-env
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../quick-start.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cli.html">Commandline Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../add-environment.html">Adding new environment to test</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Implemented SBPs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../planners.html">Motion Planners</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../samplers.html">C-space Samplers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Planning environment</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../engines.html">Simulator Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../visualisers.html">Planning Scene Visualisers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Others</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../misc.html">Misc Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../support.html">Support</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">sbp-env</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>planners.rrdtPlanner</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for planners.rrdtPlanner</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">overrides</span> <span class="kn">import</span> <span class="n">overrides</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>

<span class="kn">from</span> <span class="nn">planners.rrtPlanner</span> <span class="kn">import</span> <span class="n">RRTPlanner</span>
<span class="kn">from</span> <span class="nn">samplers.baseSampler</span> <span class="kn">import</span> <span class="n">Sampler</span>
<span class="kn">from</span> <span class="nn">samplers.randomPolicySampler</span> <span class="kn">import</span> <span class="n">RandomPolicySampler</span>
<span class="kn">from</span> <span class="nn">utils</span> <span class="kn">import</span> <span class="n">planner_registry</span>
<span class="kn">from</span> <span class="nn">utils.common</span> <span class="kn">import</span> <span class="n">BFS</span><span class="p">,</span> <span class="n">MagicDict</span>

<span class="n">LOGGER</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">MAX_NUMBER_NODES</span> <span class="o">=</span> <span class="mi">20000</span>

<span class="n">RANDOM_RESTART_EVERY</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">ENERGY_START</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">RANDOM_RESTART_PARTICLES_ENERGY_UNDER</span> <span class="o">=</span> <span class="mf">0.1</span>  <span class="c1"># .75</span>


<span class="k">def</span> <span class="nf">kernel</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">xprime</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
    <span class="n">length_scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Kernel function to be used for Bayesian RRdT</span>

<span class="sd">    :param x: bins</span>
<span class="sd">    :param xprime: origin of x</span>
<span class="sd">    :param sigma: sigma for the kernel</span>
<span class="sd">    :param length_scale: lambda for the kernel</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
        <span class="o">-</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">xprime</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="o">/</span> <span class="p">(</span><span class="n">length_scale</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="p">)</span>


<span class="k">class</span> <span class="nc">DisjointTreeParticle</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;RRdT&#39;s sampler particle&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">proposal_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">planner</span><span class="p">:</span> <span class="n">RRdTPlanner</span><span class="p">,</span>
        <span class="n">p_manager</span><span class="p">:</span> <span class="n">MABScheduler</span><span class="p">,</span>
        <span class="n">particle_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">pos</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">isroot</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DTreeType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span> <span class="o">=</span> <span class="n">p_manager</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">planner</span> <span class="o">=</span> <span class="n">planner</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">particle_idx</span>

        <span class="k">if</span> <span class="n">isroot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># root particle&#39;s tree is given, as oppose to be spawned by the particle</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reset</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree</span> <span class="o">=</span> <span class="n">isroot</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">restart</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">restart_when_merge</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1">##############################</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">last_failed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">1.5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">succeed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failed_reset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_node</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">proposal_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;dynamic-vonmises&quot;</span><span class="p">,</span> <span class="s2">&quot;ray-casting&quot;</span><span class="p">,</span> <span class="s2">&quot;original&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Given proposal type is not supported.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proposal_type</span> <span class="o">=</span> <span class="n">proposal_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_origin</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">register_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">DTreeType</span><span class="p">):</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">particle_handlers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deregister_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">DTreeType</span><span class="p">):</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">particle_handlers</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Restarts this local sampler at somewhere else.</span>

<span class="sd">        :param pos:  (Default value = None)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># I cant really get started...can i?</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No pos given&quot;</span><span class="p">)</span>
        <span class="c1"># self.energy = 1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_trying_this_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">provision_dir</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">succeed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failed_reset</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pos</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">restart_when_merge</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">merged_tree</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># get random position</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">new_pos_in_free_space</span><span class="p">()</span>
            <span class="n">merged_tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">planner</span><span class="o">.</span><span class="n">add_pos_to_existing_tree</span><span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="n">pos</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">merged_tree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">restart_when_merge</span><span class="p">:</span>
                <span class="c1"># Successfully found a new valid node that&#39;s close to existing tree</span>
                <span class="c1"># Return False to indicate it</span>
                <span class="c1"># (and abort restart if we want more exploration)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">add_to_restart</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="c1"># we need to abort the restart procedure. add this to pending restart</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deregister_tree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">)</span>
        <span class="c1"># initialise to initial value, create new d-tree</span>
        <span class="k">if</span> <span class="n">merged_tree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree</span> <span class="o">=</span> <span class="n">merged_tree</span>
            <span class="n">merged_tree</span><span class="o">.</span><span class="n">particle_handlers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># spawn a new tree</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree</span> <span class="o">=</span> <span class="n">TreeDisjoint</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">num_dim</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">register_tree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">add_newnode</span><span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="n">pos</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">planner</span><span class="o">.</span><span class="n">add_tree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">modify_energy</span><span class="p">(</span><span class="n">idx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">,</span> <span class="n">set_val</span><span class="o">=</span><span class="n">ENERGY_START</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="c1"># this particle is ready to sample again. Remove it from the pending list,</span>
        <span class="c1"># if exists</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">local_samplers_to_be_rstart</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">confirm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">provision_dir</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">rand_unit_vecs</span><span class="p">(</span><span class="n">num_dims</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">number</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">((</span><span class="n">number</span><span class="p">,</span> <span class="n">num_dims</span><span class="p">))</span>
        <span class="n">vec</span> <span class="o">=</span> <span class="n">vec</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">vec</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate_pmf</span><span class="p">(</span>
        <span class="n">num_dims</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">mu</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">kappa</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">unit_vector_support</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">assert</span> <span class="n">num_dims</span> <span class="o">&gt;=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="mi">361</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_dims</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="c1">####</span>
        <span class="k">if</span> <span class="n">unit_vector_support</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unit_vector_support</span> <span class="o">=</span> <span class="n">DisjointTreeParticle</span><span class="o">.</span><span class="n">rand_unit_vecs</span><span class="p">(</span><span class="n">num_dims</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">pmf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">kappa</span> <span class="o">*</span> <span class="n">mu</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">unit_vector_support</span><span class="p">))</span>
        <span class="n">pmf</span> <span class="o">=</span> <span class="n">pmf</span> <span class="o">/</span> <span class="n">pmf</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">unit_vector_support</span><span class="p">,</span> <span class="n">pmf</span>

    <span class="k">def</span> <span class="nf">draw_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return sample points from this particle</span>

<span class="sd">        :param origin:  (Default value = None)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;dynamic-vonmises&quot;</span><span class="p">,</span> <span class="s2">&quot;original&quot;</span><span class="p">):</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_origin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># first time</span>
                <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">num_dim</span><span class="p">))</span>
                <span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">provision_dir</span> <span class="o">=</span> <span class="n">mu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">provision_dir</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_pmf</span><span class="p">(</span>
                    <span class="n">num_dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">num_dim</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">last_origin</span><span class="p">,</span> <span class="n">kappa</span><span class="o">=</span><span class="mi">2</span>
                <span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="c1"># self.last_origin = mu</span>

        <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># use self direction if none is given.</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dir</span>

        <span class="c1"># self.last_origin = origin</span>

        <span class="c1"># use argmax or draw probabilistically</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal_type</span> <span class="o">==</span> <span class="s2">&quot;ray-casting&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_failed</span><span class="p">:</span>
                <span class="c1"># skip drawing if we haven&#39;t failed (if we are using ray-casting)</span>
                <span class="c1"># this should return the origin of where we came from</span>
                <span class="k">return</span> <span class="n">origin</span>
            <span class="n">x_idx</span> <span class="o">=</span> <span class="n">y_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
            <span class="n">xi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">x_idx</span><span class="p">]</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal_type</span> <span class="o">==</span> <span class="s2">&quot;dynamic-vonmises&quot;</span><span class="p">:</span>
            <span class="c1"># bin_width = self.x[1] - self.x[0]</span>
            <span class="n">xi_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">p</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
            <span class="n">xi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[:,</span> <span class="n">xi_idx</span><span class="p">]</span>
            <span class="c1"># xi = np.random.uniform(xi, xi + bin_width)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal_type</span> <span class="o">==</span> <span class="s2">&quot;original&quot;</span><span class="p">:</span>
            <span class="c1"># bin_width = self.x[1] - self.x[0]</span>
            <span class="n">xi_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">p</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
            <span class="n">xi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[:,</span> <span class="n">xi_idx</span><span class="p">]</span>
            <span class="c1"># xi = np.random.uniform(xi, xi + bin_width)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported proposal type&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">xi</span>  <span class="c1"># + origin</span>


<div class="viewcode-block" id="RRdTSampler"><a class="viewcode-back" href="../../samplers.html#planners.rrdtPlanner.RRdTSampler">[docs]</a><span class="k">class</span> <span class="nc">RRdTSampler</span><span class="p">(</span><span class="n">Sampler</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents RRdT&#39;s sampler&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">restart_when_merge</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">num_dtrees</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">restart_when_merge</span> <span class="o">=</span> <span class="n">restart_when_merge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_dtrees</span> <span class="o">=</span> <span class="n">num_dtrees</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_prob</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_c_random</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_choice</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_failed</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_add_particle</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">isroot</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DTreeType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DisjointTreeParticle</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">DisjointTreeParticle</span><span class="p">(</span>
                <span class="n">proposal_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">rrdt_proposal_distribution</span><span class="p">,</span>
                <span class="n">planner</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">planner</span><span class="p">,</span>
                <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span>
                <span class="n">p_manager</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="p">,</span>
                <span class="n">particle_idx</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">particles</span><span class="p">),</span>
                <span class="n">isroot</span><span class="o">=</span><span class="n">isroot</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># return the reference to the newly created particle</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<div class="viewcode-block" id="RRdTSampler.init"><a class="viewcode-back" href="../../samplers.html#planners.rrdtPlanner.RRdTSampler.init">[docs]</a>    <span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># For benchmark stats tracking</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">lsampler_restart_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">lsampler_randomwalk_counter</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">random_sampler</span> <span class="o">=</span> <span class="n">RandomPolicySampler</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_sampler</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span> <span class="o">=</span> <span class="n">MABScheduler</span><span class="p">(</span>
            <span class="n">num_dtrees</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dtrees</span><span class="p">,</span>
            <span class="n">start_pt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">start_pos</span><span class="p">,</span>
            <span class="n">goal_pt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">goal_pos</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span>
            <span class="n">random_sampler</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_sampler</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">global</span> <span class="n">MAX_NUMBER_NODES</span>
        <span class="n">MAX_NUMBER_NODES</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">max_number_nodes</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">num_dtrees</span> <span class="o">&gt;=</span> <span class="mi">2</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">num_dtrees</span> <span class="o">-</span> <span class="mi">2</span>
        <span class="p">):</span>  <span class="c1"># minus two for start and goal point</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_particle</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">new_pos_in_free_space</span><span class="p">())</span>
        <span class="c1"># spawn one that comes from the goal</span>
        <span class="n">goal_dt_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_particle</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">goal_pos</span><span class="p">)</span>
        <span class="n">goal_dt_p</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">add_newnode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">goal_pt</span><span class="p">)</span>

        <span class="c1"># spawn one that comes from the root</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">planner</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">TreeRoot</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">num_dim</span><span class="p">)</span>
        <span class="n">root_particle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_particle</span><span class="p">(</span>
            <span class="n">pos</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">start_pos</span><span class="p">,</span> <span class="n">isroot</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">planner</span><span class="o">.</span><span class="n">root</span>
        <span class="p">)</span>
        <span class="n">root_particle</span><span class="o">.</span><span class="n">register_tree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">planner</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>
        <span class="n">root_particle</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">add_newnode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">start_pt</span><span class="p">)</span></div>

<div class="viewcode-block" id="RRdTSampler.particles_random_free_space_restart"><a class="viewcode-back" href="../../samplers.html#planners.rrdtPlanner.RRdTSampler.particles_random_free_space_restart">[docs]</a>    <span class="k">def</span> <span class="nf">particles_random_free_space_restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Randomly restarts particle in :math:`C_\text{free}`&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">num_dtrees</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">dtrees_energy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">RANDOM_RESTART_PARTICLES_ENERGY_UNDER</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">add_to_restart</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">])</span></div>

<div class="viewcode-block" id="RRdTSampler.report_success"><a class="viewcode-back" href="../../samplers.html#planners.rrdtPlanner.RRdTSampler.report_success">[docs]</a>    <span class="k">def</span> <span class="nf">report_success</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Report that the sample returned by particle with index ``idx`` was</span>
<span class="sd">        successful</span>

<span class="sd">        :param idx: the index of the particle</span>
<span class="sd">        :param newnode: the node that was created</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">last_node</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;newnode&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">confirm</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;pos&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_failed</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">particle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="c1"># update pmf</span>
        <span class="n">particle</span><span class="o">.</span><span class="n">succeed</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">particle</span><span class="o">.</span><span class="n">failed_reset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">particle</span><span class="o">.</span><span class="n">last_origin</span> <span class="o">=</span> <span class="n">particle</span><span class="o">.</span><span class="n">provision_dir</span>
        <span class="k">if</span> <span class="n">particle</span><span class="o">.</span><span class="n">proposal_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;dynamic-vonmises&quot;</span><span class="p">,</span> <span class="s2">&quot;ray-casting&quot;</span><span class="p">,</span> <span class="s2">&quot;original&quot;</span><span class="p">):</span>
            <span class="c1"># reset to the original von mises</span>
            <span class="c1"># TODO make a sharper von mises distribution (higher kappa) when success</span>
            <span class="c1"># particle.A = particle.y.copy()</span>
            <span class="n">particle</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">particle</span><span class="o">.</span><span class="n">last_failed</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="RRdTSampler.report_fail"><a class="viewcode-back" href="../../samplers.html#planners.rrdtPlanner.RRdTSampler.report_fail">[docs]</a>    <span class="k">def</span> <span class="nf">report_fail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reports that the sampled position from the particle had failed</span>

<span class="sd">        :param idx: the index of the particle</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_failed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">particle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">modify_energy</span><span class="p">(</span><span class="n">idx</span><span class="o">=</span><span class="n">idx</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
            <span class="c1"># update pmf</span>
            <span class="n">particle</span><span class="o">.</span><span class="n">failed_reset</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">particle</span><span class="o">.</span><span class="n">failed</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">particle</span><span class="o">.</span><span class="n">proposal_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;dynamic-vonmises&quot;</span><span class="p">,</span> <span class="s2">&quot;ray-casting&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">particle</span><span class="o">.</span><span class="n">last_origin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># still in phrase 1</span>
                    <span class="k">return</span>
                <span class="n">particle</span><span class="o">.</span><span class="n">last_failed</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># get previous trying direction</span>
                <span class="n">xi</span> <span class="o">=</span> <span class="n">particle</span><span class="o">.</span><span class="n">provision_dir</span>

                <span class="c1"># revert effect of shifting origin</span>
                <span class="n">xi</span> <span class="o">-=</span> <span class="n">particle</span><span class="o">.</span><span class="n">last_origin</span>

                <span class="c1"># find cloest x idx</span>
                <span class="n">particle</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">particle</span><span class="o">.</span><span class="n">A</span> <span class="o">-</span> <span class="n">kernel</span><span class="p">(</span>
                    <span class="n">particle</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>
                    <span class="n">xi</span><span class="p">,</span>
                    <span class="n">sigma</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">particle</span><span class="o">.</span><span class="n">A</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.9</span><span class="p">,</span>
                    <span class="n">length_scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">10</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">particle</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">particle</span><span class="o">.</span><span class="n">A</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">particle</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="RRdTSampler.restart_all_pending_local_samplers"><a class="viewcode-back" href="../../samplers.html#planners.rrdtPlanner.RRdTSampler.restart_all_pending_local_samplers">[docs]</a>    <span class="k">def</span> <span class="nf">restart_all_pending_local_samplers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Restarts all disjointed-tree particle that are pending to be restarts&quot;&quot;&quot;</span>
        <span class="c1"># restart all pending local samplers</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">local_samplers_to_be_rstart</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># during the proces of restart, if the new restart position</span>
            <span class="c1"># is close to an existing tree, it will simply add to that new tree.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">local_samplers_to_be_rstart</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">restart</span><span class="p">(</span>
                <span class="n">restart_when_merge</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">restart_when_merge</span>
            <span class="p">):</span>
                <span class="c1"># This flag denotes that a new position was found among the trees,</span>
                <span class="c1"># And it NEEDS to get back to restarting particles in the next ierations</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="RRdTSampler.get_next_pos"><a class="viewcode-back" href="../../samplers.html#planners.rrdtPlanner.RRdTSampler.get_next_pos">[docs]</a>    <span class="k">def</span> <span class="nf">get_next_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_c_random</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c_random</span> <span class="o">&gt;</span> <span class="n">RANDOM_RESTART_EVERY</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_c_random</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">particles_random_free_space_restart</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">restart_all_pending_local_samplers</span><span class="p">():</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Adding node to existing trees.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># get a node to random walk</span>
        <span class="n">choice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_random_choice</span><span class="p">()</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_walk</span><span class="p">(</span><span class="n">choice</span><span class="p">)</span>
        <span class="c1"># pos, choice = self.random_walk_by_mouse()</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">pos</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="n">choice</span><span class="p">]</span><span class="o">.</span><span class="n">tree</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="n">choice</span><span class="p">]</span><span class="o">.</span><span class="n">last_node</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">c</span><span class="o">=</span><span class="n">choice</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">report_success</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span>
            <span class="k">lambda</span> <span class="n">c</span><span class="o">=</span><span class="n">choice</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">report_fail</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="RRdTSampler.random_walk_by_mouse"><a class="viewcode-back" href="../../samplers.html#planners.rrdtPlanner.RRdTSampler.random_walk_by_mouse">[docs]</a>    <span class="k">def</span> <span class="nf">random_walk_by_mouse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Random walk by mouse</span>

<span class="sd">        .. warning::</span>
<span class="sd">            For testing purpose. Mimic random walk, but do so via mouse click.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">samplers.mouseSampler</span> <span class="kn">import</span> <span class="n">MouseSampler</span> <span class="k">as</span> <span class="n">mouse</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="n">mouse</span><span class="o">.</span><span class="n">get_mouse_click_position</span><span class="p">(</span><span class="n">scaling</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">scaling</span><span class="p">)</span>
        <span class="c1"># find the cloest particle from this position</span>
        <span class="n">_dist</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">p_idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">particles</span><span class="p">)):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">_dist</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">_dist</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">dist</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">pos</span><span class="p">):</span>
                <span class="n">_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">dist</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>
                <span class="n">p_idx</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;num of tree: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">planner</span><span class="o">.</span><span class="n">_disjointed_trees</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">new_pos</span><span class="p">(</span><span class="n">idx</span><span class="o">=</span><span class="n">p_idx</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pos</span><span class="p">,</span> <span class="n">p_idx</span></div>

<div class="viewcode-block" id="RRdTSampler.random_walk"><a class="viewcode-back" href="../../samplers.html#planners.rrdtPlanner.RRdTSampler.random_walk">[docs]</a>    <span class="k">def</span> <span class="nf">random_walk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Performs a random walk for the particle at the given index</span>

<span class="sd">        :param idx: the index of the particle</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">lsampler_randomwalk_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Randomly bias toward goal direction</span>
        <span class="k">if</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">goalBias</span><span class="p">:</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">goal_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">get_pos</span><span class="p">(</span><span class="n">idx</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">goal_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">get_pos</span><span class="p">(</span><span class="n">idx</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">goal_direction</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">dy</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
            <span class="n">new_direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">draw_sample</span><span class="p">(</span>
                <span class="n">origin</span><span class="o">=</span><span class="n">goal_direction</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">draw_sample</span><span class="p">()</span>

        <span class="n">new_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">get_pos</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">+</span> <span class="n">new_direction</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">epsilon</span> <span class="o">*</span> <span class="mi">3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">new_pos</span><span class="p">(</span><span class="n">idx</span><span class="o">=</span><span class="n">idx</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">new_pos</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="n">new_direction</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_pos</span></div>

<div class="viewcode-block" id="RRdTSampler.get_random_choice"><a class="viewcode-back" href="../../samplers.html#planners.rrdtPlanner.RRdTSampler.get_random_choice">[docs]</a>    <span class="k">def</span> <span class="nf">get_random_choice</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a random particle (disjointed tree) from the currently managed particiles</span>

<span class="sd">        :return: Node from p_manager</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">num_dtrees</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">get_prob</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_prob</span> <span class="o">=</span> <span class="n">prob</span>  <span class="c1"># this will be used to paint particles</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">choice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">num_dtrees</span><span class="p">),</span> <span class="n">p</span><span class="o">=</span><span class="n">prob</span><span class="p">)</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="n">choice</span><span class="p">]</span><span class="o">.</span><span class="n">tree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="n">choice</span><span class="p">]</span><span class="o">.</span><span class="n">tree</span><span class="p">,</span> <span class="s2">&quot;poses&quot;</span><span class="p">),</span> <span class="nb">hex</span><span class="p">(</span>
                <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="n">choice</span><span class="p">]</span><span class="o">.</span><span class="n">tree</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># NOTE dont know why the probability got out of sync... (not sums to 1)</span>
            <span class="c1"># probably because of underflow?</span>
            <span class="c1"># We will notify the use, then try re-sync the prob</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;!! probability got exception &#39;</span><span class="si">{}</span><span class="s2">&#39;... trying to re-sync prob again.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">e</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">resync_prob</span><span class="p">()</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">get_prob</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_last_prob</span> <span class="o">=</span> <span class="n">prob</span>
            <span class="n">choice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">num_dtrees</span><span class="p">),</span> <span class="n">p</span><span class="o">=</span><span class="n">prob</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_choice</span> <span class="o">=</span> <span class="n">choice</span>
        <span class="k">return</span> <span class="n">choice</span></div></div>


<span class="c1">############################################################</span>
<span class="c1">##    PATCHING RRT with disjointed-tree specific stuff    ##</span>
<span class="c1">############################################################</span>


<span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Overloads the Tree-based node with extra info&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># index 0 is x, index 1 is y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_start</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_goal</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">num_edges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">num_edges</span> <span class="o">=</span> <span class="s2">&quot;DELETED&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;Node(pos=</span><span class="si">{}</span><span class="s2">, cost=</span><span class="si">{}</span><span class="s2">, num_edges=</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost</span><span class="p">,</span> <span class="n">num_edges</span>
        <span class="p">)</span>


<div class="viewcode-block" id="RRdTPlanner"><a class="viewcode-back" href="../../planners.html#planners.rrdtPlanner.RRdTPlanner">[docs]</a><span class="k">class</span> <span class="nc">RRdTPlanner</span><span class="p">(</span><span class="n">RRTPlanner</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;The Rapidly-exploring Random disjointed-Trees.</span>
<span class="sd">    The RRdT* planner is implemented based on Lai *et. al.*&#39;s [#Lai]_ work.</span>
<span class="sd">    The main idea is that the planner keeps a pool of disjointed trees</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathbb{T}=\{\mathcal{T}_\text{root}, \mathcal{T}_1, \ldots, \mathcal{T}_k\}</span>

<span class="sd">    where it consists of a rooted tree that connects to the :math:`q_\text{start}`</span>
<span class="sd">    starting configuration, and :math:`k` many disjointed trees that randomly explores</span>
<span class="sd">    *C-Space*.</span>
<span class="sd">    Each disjointed tree is modelled as an arm in the Multi-Armed Bandit problem,</span>
<span class="sd">    i.e. each :math:`\mathcal{T}_i` has an arm :math:`a_i`, where the probability to</span>
<span class="sd">    draw each arm is dependent on its previous success as given by</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathbb{P}(a_{i,t} \mid a_{i,t-1}, o_{t-1})\,\forall_{i\in\{1,...,k\}}</span>

<span class="sd">    with :math:`o_{t-1}` as the arm :math:`a_i`&#39;s previous observation.</span>


<span class="sd">    .. [#Lai] Lai, Tin, Fabio Ramos, and Gilad Francis. &quot;Balancing global</span>
<span class="sd">        exploration and local-connectivity exploitation with rapidly-exploring random</span>
<span class="sd">        disjointed-trees.&quot; 2019 International Conference on Robotics and Automation (</span>
<span class="sd">        ICRA). IEEE, 2019.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_disjointed_trees</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="RRdTPlanner.run_once"><a class="viewcode-back" href="../../planners.html#planners.rrdtPlanner.RRdTPlanner.run_once">[docs]</a>    <span class="nd">@overrides</span>
    <span class="k">def</span> <span class="nf">run_once</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Get an sample that is free (not in blocked space)</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_next_pos</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">_tmp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># This denotes a particle had tried to restart and added the new node</span>
                <span class="c1"># to existing tree instead.</span>
                <span class="c1"># Skip remaining steps and iterate to next loop</span>
                <span class="k">break</span>
            <span class="n">rand_pos</span> <span class="o">=</span> <span class="n">_tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">add_sampled_node</span><span class="p">(</span><span class="n">rand_pos</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">cc</span><span class="o">.</span><span class="n">feasible</span><span class="p">(</span><span class="n">rand_pos</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampler_success</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">break</span>
            <span class="n">report_fail</span> <span class="o">=</span> <span class="n">_tmp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">report_fail</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="n">rand_pos</span><span class="p">,</span> <span class="n">obstacle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">add_invalid</span><span class="p">(</span><span class="n">obs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampler_fail</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampler_success_all</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">_tmp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># we have added a new samples when respawning a local sampler</span>
            <span class="k">return</span>
        <span class="n">rand_pos</span><span class="p">,</span> <span class="n">parent_tree</span><span class="p">,</span> <span class="n">last_node</span><span class="p">,</span> <span class="n">report_success</span><span class="p">,</span> <span class="n">report_fail</span> <span class="o">=</span> <span class="n">_tmp</span>
        <span class="k">if</span> <span class="n">last_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="kc">False</span><span class="p">:</span>
            <span class="c1"># use the last succesful node as the nearest node</span>
            <span class="c1"># This is expliting the advantage of local sampler :)</span>
            <span class="n">nn</span> <span class="o">=</span> <span class="n">last_node</span>
            <span class="n">newpos</span> <span class="o">=</span> <span class="n">rand_pos</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_nearest_neighbour_idx</span><span class="p">(</span>
                <span class="n">rand_pos</span><span class="p">,</span> <span class="n">parent_tree</span><span class="o">.</span><span class="n">poses</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">parent_tree</span><span class="o">.</span><span class="n">nodes</span><span class="p">)]</span>
            <span class="p">)</span>
            <span class="n">nn</span> <span class="o">=</span> <span class="n">parent_tree</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="c1"># get an intermediate node according to step-size</span>
            <span class="n">newpos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">step_from_to</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">rand_pos</span><span class="p">)</span>
        <span class="c1"># check if it is free or not</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">cc</span><span class="o">.</span><span class="n">visible</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">newpos</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">add_invalid</span><span class="p">(</span><span class="n">obs</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">report_fail</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="n">rand_pos</span><span class="p">,</span> <span class="n">free</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newnode</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">newpos</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">add_free</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">add_tree_node</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="n">newnode</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>
            <span class="n">report_success</span><span class="p">(</span><span class="n">newnode</span><span class="o">=</span><span class="n">newnode</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">newnode</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>
            <span class="c1">######################</span>
            <span class="n">newnode</span><span class="p">,</span> <span class="n">nn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connect_two_nodes</span><span class="p">(</span><span class="n">newnode</span><span class="p">,</span> <span class="n">nn</span><span class="p">,</span> <span class="n">parent_tree</span><span class="p">)</span>
            <span class="c1"># try to add this newnode to existing trees</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_pos_to_existing_tree</span><span class="p">(</span><span class="n">newnode</span><span class="p">,</span> <span class="n">parent_tree</span><span class="p">)</span></div>

<div class="viewcode-block" id="RRdTPlanner.rrt_star_add_node"><a class="viewcode-back" href="../../planners.html#planners.rrdtPlanner.RRdTPlanner.rrt_star_add_node">[docs]</a>    <span class="k">def</span> <span class="nf">rrt_star_add_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newnode</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">nn</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This function perform finding optimal parent, and rewiring.</span>

<span class="sd">        :param newnode: the node to add to the tree</span>
<span class="sd">        :param nn: an approximate of nearest node</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">newnode</span><span class="p">,</span> <span class="n">nn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">choose_least_cost_parent</span><span class="p">(</span>
            <span class="n">newnode</span><span class="p">,</span> <span class="n">nn</span><span class="o">=</span><span class="n">nn</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">nodes</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rewire</span><span class="p">(</span><span class="n">newnode</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>

        <span class="c1"># newnode.parent = nn</span>

        <span class="c1"># check for goal condition</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">dist</span><span class="p">(</span><span class="n">newnode</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">goal_pt</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">goal_radius</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">cc</span><span class="o">.</span><span class="n">visible</span><span class="p">(</span><span class="n">newnode</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">goal_pt</span><span class="o">.</span><span class="n">pos</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">newnode</span><span class="o">.</span><span class="n">cost</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_max</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">c_max</span> <span class="o">=</span> <span class="n">newnode</span><span class="o">.</span><span class="n">cost</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">goal_pt</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">newnode</span>
                    <span class="n">newnode</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">goal_pt</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
        <span class="c1"># add node to tree</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_newnode</span><span class="p">(</span><span class="n">newnode</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newnode</span><span class="p">,</span> <span class="n">nn</span></div>

    <span class="c1">##################################################</span>
    <span class="c1"># Tree management:</span>
    <span class="c1">##################################################</span>
<div class="viewcode-block" id="RRdTPlanner.connect_two_nodes"><a class="viewcode-back" href="../../planners.html#planners.rrdtPlanner.RRdTPlanner.connect_two_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">connect_two_nodes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">newnode</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">nn</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="n">parent_tree</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DTreeType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add node to disjoint tree OR root tree.</span>

<span class="sd">        :param newnode: the new node to connects</span>
<span class="sd">        :param nn: a node from the existing tree to be connected</span>
<span class="sd">        :param parent_tree: if given, add newnode to this tree</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">parent_tree</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">:</span>
            <span class="c1"># using rrt* algorithm to add each nodes</span>
            <span class="n">newnode</span><span class="p">,</span> <span class="n">nn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rrt_star_add_node</span><span class="p">(</span><span class="n">newnode</span><span class="p">,</span> <span class="n">nn</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newnode</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nn</span><span class="p">)</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newnode</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">parent_tree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parent_tree</span><span class="o">.</span><span class="n">add_newnode</span><span class="p">(</span><span class="n">newnode</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newnode</span><span class="p">,</span> <span class="n">nn</span></div>

<div class="viewcode-block" id="RRdTPlanner.add_pos_to_existing_tree"><a class="viewcode-back" href="../../planners.html#planners.rrdtPlanner.RRdTPlanner.add_pos_to_existing_tree">[docs]</a>    <span class="k">def</span> <span class="nf">add_pos_to_existing_tree</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">newnode</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">parent_tree</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DTreeType</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DTreeType</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Try to add pos to existing tree. If success, return True.</span>

<span class="sd">        :param newnode: the node to be added</span>
<span class="sd">        :param parent_tree: the tree to add the node</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nearest_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_nearest_node_from_neighbour</span><span class="p">(</span>
            <span class="n">node</span><span class="o">=</span><span class="n">newnode</span><span class="p">,</span> <span class="n">parent_tree</span><span class="o">=</span><span class="n">parent_tree</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">epsilon</span>
        <span class="p">)</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">nearest_neighbour_node</span><span class="p">,</span> <span class="n">nearest_neighbour_tree</span> <span class="ow">in</span> <span class="n">nearest_nodes</span><span class="p">:</span>
            <span class="c1"># for nearest_neighbour_node, nearest_neighbour_tree in nearest_nodes:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">cc</span><span class="o">.</span><span class="n">visible</span><span class="p">(</span><span class="n">newnode</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">nearest_neighbour_node</span><span class="o">.</span><span class="n">pos</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">parent_tree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1">### joining ORPHAN NODE to a tree</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">connect_two_nodes</span><span class="p">(</span>
                        <span class="n">newnode</span><span class="p">,</span> <span class="n">nearest_neighbour_node</span><span class="p">,</span> <span class="n">nearest_neighbour_tree</span>
                    <span class="p">)</span>
                    <span class="n">parent_tree</span> <span class="o">=</span> <span class="n">nearest_neighbour_tree</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">### joining a TREE to another tree</span>
                    <span class="c1"># try:</span>
                    <span class="n">parent_tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">join_trees</span><span class="p">(</span>
                        <span class="n">parent_tree</span><span class="p">,</span>
                        <span class="n">nearest_neighbour_tree</span><span class="p">,</span>
                        <span class="n">tree1_node</span><span class="o">=</span><span class="n">newnode</span><span class="p">,</span>
                        <span class="n">tree2_node</span><span class="o">=</span><span class="n">nearest_neighbour_node</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="c1"># return parent_tree</span>
                    <span class="c1"># except AssertionError as e:</span>
                    <span class="c1">#     raise e</span>
                    <span class="c1">#     LOGGER.warning(</span>
                    <span class="c1">#         &quot;Assertion error in joining sampled pt to existing tree.&quot;</span>
                    <span class="c1">#         &quot;Skipping this node...&quot;</span>
                    <span class="c1">#     )</span>
                <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">parent_tree</span></div>

<div class="viewcode-block" id="RRdTPlanner.find_nearest_node_from_neighbour"><a class="viewcode-back" href="../../planners.html#planners.rrdtPlanner.RRdTPlanner.find_nearest_node_from_neighbour">[docs]</a>    <span class="k">def</span> <span class="nf">find_nearest_node_from_neighbour</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">parent_tree</span><span class="p">:</span> <span class="n">DTreeType</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Node</span><span class="p">,</span> <span class="n">DTreeType</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Given a tree, a node within that tree, and radius</span>
<span class="sd">        Return a list of cloest nodes (and its corresponding tree) within the radius (that&#39;s from other neighbourhood trees)</span>

<span class="sd">        :param node: the node to be added</span>
<span class="sd">        :param parent_tree: the tree to add the given node</span>
<span class="sd">        :param radius: the maximum radius to add the given node</span>

<span class="sd">        :returns: a list of potential nodes</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># IF root exists in the list, add it at the last position (So the connection</span>
        <span class="c1"># behaviour would remain stable)</span>
        <span class="c1"># This ensure all previous action would only add add edges to each nodes,</span>
        <span class="c1"># and only the last action would it modifies the entire tree structures with</span>
        <span class="c1"># rrt* procedures.</span>
        <span class="n">nearest_nodes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="p">[</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_disjointed_trees</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">tree</span> <span class="ow">is</span> <span class="n">parent_tree</span><span class="p">:</span>
                <span class="c1"># skip self</span>
                <span class="k">continue</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_nearest_neighbour_idx</span><span class="p">(</span>
                <span class="n">node</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">poses</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">nodes</span><span class="p">)]</span>
            <span class="p">)</span>
            <span class="n">nn</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">dist</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">radius</span><span class="p">:</span>
                <span class="n">nearest_nodes</span><span class="p">[</span><span class="n">tree</span><span class="p">]</span> <span class="o">=</span> <span class="n">nn</span>
        <span class="c1"># construct list of the found solution.</span>
        <span class="c1"># And root at last (or else the result won&#39;t be stable)</span>
        <span class="n">root_nn</span> <span class="o">=</span> <span class="n">nearest_nodes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">nearest_nodes_list</span> <span class="o">=</span> <span class="p">[(</span><span class="n">nearest_nodes</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">nearest_nodes</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">root_nn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nearest_nodes_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">root_nn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">nearest_nodes_list</span></div>

<div class="viewcode-block" id="RRdTPlanner.join_tree_to_root"><a class="viewcode-back" href="../../planners.html#planners.rrdtPlanner.RRdTPlanner.join_tree_to_root">[docs]</a>    <span class="k">def</span> <span class="nf">join_tree_to_root</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">DTreeType</span><span class="p">,</span> <span class="n">middle_node</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">root_tree_node</span><span class="p">:</span> <span class="n">Node</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;It will join the given tree to the root</span>

<span class="sd">        :param tree: the disjointed tree to be added to root tree</span>
<span class="sd">        :param middle_node: the middle node that connects the disjointed tree and the</span>
<span class="sd">            root tree</span>
<span class="sd">        :param root_tree_node: a node from the root tree</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># from env import Colour</span>
        <span class="n">bfs</span> <span class="o">=</span> <span class="n">BFS</span><span class="p">(</span><span class="n">middle_node</span><span class="p">,</span> <span class="n">validNodes</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
        <span class="c1"># add all nodes from disjoint tree via rrt star method</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;&gt; Joining to root tree&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">desc</span><span class="o">=</span><span class="s2">&quot;join to root&quot;</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span> <span class="k">as</span> <span class="n">pbar</span><span class="p">:</span>

            <span class="n">nn</span> <span class="o">=</span> <span class="n">middle_node</span>

            <span class="n">bfs</span> <span class="o">=</span> <span class="n">BFS</span><span class="p">(</span><span class="n">middle_node</span><span class="p">,</span> <span class="n">validNodes</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
            <span class="n">nn</span> <span class="o">=</span> <span class="n">root_tree_node</span>
            <span class="k">while</span> <span class="n">bfs</span><span class="o">.</span><span class="n">has_next</span><span class="p">():</span>
                <span class="n">newnode</span> <span class="o">=</span> <span class="n">bfs</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
                <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">newnode</span><span class="p">,</span> <span class="n">nn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connect_two_nodes</span><span class="p">(</span>
                        <span class="n">newnode</span><span class="p">,</span> <span class="n">nn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parent_tree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span>
                    <span class="p">)</span>
                    <span class="n">nn</span> <span class="o">=</span> <span class="n">newnode</span>
                <span class="k">except</span> <span class="ne">LookupError</span><span class="p">:</span>
                    <span class="n">LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="s2">&quot;nn not found when attempting to joint to root. Ignoring...&quot;</span>
                    <span class="p">)</span>
                <span class="c1"># remove this node&#39;s edges (as we don&#39;t have a use on them anymore)</span>
                <span class="c1"># to free memory</span>
                <span class="k">del</span> <span class="n">newnode</span><span class="o">.</span><span class="n">edges</span></div>

        <span class="c1"># assert progress == total_num, &quot;Inconsistency in BFS walk {} != {}&quot;.format(</span>
        <span class="c1">#     progress, total_num)</span>

<div class="viewcode-block" id="RRdTPlanner.join_trees"><a class="viewcode-back" href="../../planners.html#planners.rrdtPlanner.RRdTPlanner.join_trees">[docs]</a>    <span class="k">def</span> <span class="nf">join_trees</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">tree1</span><span class="p">:</span> <span class="n">DTreeType</span><span class="p">,</span>
        <span class="n">tree2</span><span class="p">:</span> <span class="n">DTreeType</span><span class="p">,</span>
        <span class="n">tree1_node</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
        <span class="n">tree2_node</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Join the two given tree together (along with their nodes).</span>
<span class="sd">        It will delete the particle reference from the second tree.</span>
<span class="sd">        It will use RRT* method to add all nodes if one of the tree is the ROOT.</span>

<span class="sd">        tree1_node &amp; 2 represent the nodes that join the two tree together.</span>
<span class="sd">        It only matters currently to joining root tree to disjointed tree itself.</span>

<span class="sd">        :param tree1: disjointed tree 1 :math:`\mathcal{T}_1`</span>
<span class="sd">        :param tree2: disjointed tree 2 :math:`\mathcal{T}_2`</span>
<span class="sd">        :param tree1_node: a node from tree 1 :math:`v_1 \in \mathcal{T}_1`</span>
<span class="sd">        :param tree2_node: a node from tree 2 :math:`v_2 \in \mathcal{T}_2`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">tree1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">tree2</span><span class="p">,</span> <span class="s2">&quot;Both given tree should not be the same&quot;</span>

        <span class="k">def</span> <span class="nf">assert_tree_in_dtrees</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">tree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_disjointed_trees</span>
            <span class="p">)</span> <span class="o">==</span> <span class="n">value</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Checks &#39;tree in self._disjointed_trees == </span><span class="si">{value}</span><span class="s2">&#39; fails, </span><span class="si">{tree}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">tree1</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">:</span>
            <span class="n">assert_tree_in_dtrees</span><span class="p">(</span><span class="n">tree1</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">assert_tree_in_dtrees</span><span class="p">(</span><span class="n">tree2</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">tree2</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">:</span>
            <span class="n">assert_tree_in_dtrees</span><span class="p">(</span><span class="n">tree1</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">assert_tree_in_dtrees</span><span class="p">(</span><span class="n">tree2</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">assert_tree_in_dtrees</span><span class="p">(</span><span class="n">tree1</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">assert_tree_in_dtrees</span><span class="p">(</span><span class="n">tree2</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot; =&gt; Joining trees with size </span><span class="si">{}</span><span class="s2"> to </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">tree1</span><span class="o">.</span><span class="n">nodes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree2</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># Re-arrange only. Make it so that tree1 will always be root (if root exists among the two)</span>
        <span class="c1"># And tree1 node must always be belong to tree1, tree2 node belong to tree2</span>
        <span class="k">if</span> <span class="n">tree1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">:</span>
            <span class="c1"># set tree1 as root (if root exists among the two)</span>
            <span class="n">tree1</span><span class="p">,</span> <span class="n">tree2</span> <span class="o">=</span> <span class="n">tree2</span><span class="p">,</span> <span class="n">tree1</span>
        <span class="k">if</span> <span class="n">tree1_node</span> <span class="ow">in</span> <span class="n">tree2</span><span class="o">.</span><span class="n">nodes</span> <span class="ow">or</span> <span class="n">tree2_node</span> <span class="ow">in</span> <span class="n">tree1</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="c1"># swap to correct position</span>
            <span class="n">tree1_node</span><span class="p">,</span> <span class="n">tree2_node</span> <span class="o">=</span> <span class="n">tree2_node</span><span class="p">,</span> <span class="n">tree1_node</span>

        <span class="k">if</span> <span class="n">tree1</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">:</span>
            <span class="c1"># find which middle_node belongs to the disjointed tree</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">join_tree_to_root</span><span class="p">(</span><span class="n">tree2</span><span class="p">,</span> <span class="n">tree2_node</span><span class="p">,</span> <span class="n">root_tree_node</span><span class="o">=</span><span class="n">tree1_node</span><span class="p">)</span>
            <span class="c1"># self.connect_two_nodes(tree1_node, tree2_node, draw_only=True)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connect_two_nodes</span><span class="p">(</span><span class="n">tree1_node</span><span class="p">,</span> <span class="n">tree2_node</span><span class="p">)</span>
            <span class="n">tree1</span><span class="o">.</span><span class="n">extend_tree</span><span class="p">(</span><span class="n">tree2</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">tree2</span><span class="o">.</span><span class="n">nodes</span>
        <span class="k">del</span> <span class="n">tree2</span><span class="o">.</span><span class="n">poses</span>

        <span class="c1"># remove the tree from the list of trees first, so that when the particle is</span>
        <span class="c1"># restarting it wont try to connects back to the, now non-existence, tree.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_tree</span><span class="p">(</span><span class="n">tree2</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">restart_when_merge</span><span class="p">:</span>
            <span class="c1"># restart all particles</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">tree2</span><span class="o">.</span><span class="n">particle_handlers</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">add_to_restart</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="n">p</span><span class="o">.</span><span class="n">tree</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="c1"># p.restart()</span>
            <span class="k">del</span> <span class="n">tree2</span><span class="o">.</span><span class="n">particle_handlers</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># pass the remaining particle to the remaining tree</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">tree2</span><span class="o">.</span><span class="n">particle_handlers</span><span class="p">:</span>
                <span class="n">p</span><span class="o">.</span><span class="n">tree</span> <span class="o">=</span> <span class="n">tree1</span>
                <span class="n">tree1</span><span class="o">.</span><span class="n">particle_handlers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tree1</span></div>

    <span class="c1"># Tree management</span>
    <span class="k">def</span> <span class="nf">add_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_disjointed_trees</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_disjointed_trees</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span></div>


<span class="c1">############################################################</span>
<span class="c1"># d-tree classes</span>
<span class="c1">############################################################</span>


<span class="k">class</span> <span class="nc">DTreeType</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Abstract d-tree type&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">particle_handlers</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">DisjointTreeParticle</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="p">(</span><span class="n">MAX_NUMBER_NODES</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">50</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
        <span class="p">)</span>  <span class="c1"># +50 to prevent over flow</span>
        <span class="c1"># This stores the last node added to this tree (by local sampler)</span>

    <span class="k">def</span> <span class="nf">add_newnode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a new node to the d-tree</span>

<span class="sd">        :param node: the node to be added</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poses</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">pos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">extend_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">DTreeType</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extend nodes from the given tree to this tree</span>

<span class="sd">        :param tree: the tree to be extended</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poses</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">nodes</span><span class="p">)]</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">poses</span><span class="p">[</span>
            <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">string</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="kn">import</span> <span class="nn">pprint</span>

        <span class="n">string</span> <span class="o">+=</span> <span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="nb">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="c1"># string += &#39;, &#39;.join(&quot;%s: %s&quot; % item for item in vars(self).items())</span>
        <span class="k">return</span> <span class="n">string</span>


<span class="k">class</span> <span class="nc">TreeRoot</span><span class="p">(</span><span class="n">DTreeType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents the root&quot;&quot;&quot;</span>

    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">TreeDisjoint</span><span class="p">(</span><span class="n">DTreeType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents one d-tree&quot;&quot;&quot;</span>

    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">MABScheduler</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Scheduler for the MAB procedure&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">num_dtrees</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">start_pt</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">goal_pt</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">args</span><span class="p">:</span> <span class="n">MagicDict</span><span class="p">,</span>
        <span class="n">random_sampler</span><span class="p">:</span> <span class="n">Sampler</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_dtrees</span> <span class="o">=</span> <span class="n">num_dtrees</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_energy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">particles</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">DisjointTreeParticle</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local_samplers_to_be_rstart</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">DisjointTreeParticle</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">goal_pt</span> <span class="o">=</span> <span class="n">goal_pt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_sampler</span> <span class="o">=</span> <span class="n">random_sampler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>

    <span class="k">def</span> <span class="nf">add_to_restart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lsampler</span><span class="p">:</span> <span class="n">DisjointTreeParticle</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">lsampler</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_samplers_to_be_rstart</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">local_samplers_to_be_rstart</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lsampler</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">init_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtrees_energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dtrees</span><span class="p">)</span> <span class="o">*</span> <span class="n">ENERGY_START</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resync_prob</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">modify_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">set_val</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Modify the energy of the given particle</span>

<span class="sd">        :param idx: index of the target particle</span>
<span class="sd">        :param factor: scalar factor</span>
<span class="sd">        :param set_val: if given, set the value.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># keep track how much energy this operation would modify,</span>
        <span class="c1"># so we can change the energy_sum accordingly</span>
        <span class="n">old_energy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtrees_energy</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">set_val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dtrees_energy</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">set_val</span>
        <span class="k">elif</span> <span class="n">factor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dtrees_energy</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*=</span> <span class="n">factor</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Nothing set in modify_energy&quot;</span><span class="p">)</span>

        <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtrees_energy</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">old_energy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cur_energy_sum</span> <span class="o">+=</span> <span class="n">delta</span>

    <span class="k">def</span> <span class="nf">confirm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">pos</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">confirm</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">new_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">pos</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">dir</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">provision_dir</span> <span class="o">=</span> <span class="nb">dir</span>

    <span class="k">def</span> <span class="nf">get_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span>

    <span class="k">def</span> <span class="nf">get_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtrees_energy</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_energy_sum</span>

    <span class="k">def</span> <span class="nf">resync_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtrees_energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtrees_energy</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtrees_energy</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">:</span>
            <span class="c1"># particle_energy demonlished to 0...</span>
            <span class="c1"># work around to add energy all particles</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dtrees_energy</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cur_energy_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtrees_energy</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">new_pos_in_free_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new position in free space.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">lsampler_restart_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>

            <span class="n">new_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_sampler</span><span class="o">.</span><span class="n">get_next_pos</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">add_sampled_node</span><span class="p">(</span><span class="n">new_p</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">cc</span><span class="o">.</span><span class="n">feasible</span><span class="p">(</span><span class="n">new_p</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">add_invalid</span><span class="p">(</span><span class="n">obs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">add_free</span><span class="p">()</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">new_p</span>


<span class="k">def</span> <span class="nf">pygame_rrdt_sampler_paint_init</span><span class="p">(</span><span class="n">sampler</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Visualisation init function for rrdt sampler</span>

<span class="sd">    :param sampler: sampler to be visualised</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">pygame</span>

    <span class="n">sampler</span><span class="o">.</span><span class="n">particles_layer</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Surface</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="n">sampler</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">sampler</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">scaling</span><span class="p">,</span>
            <span class="n">sampler</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">sampler</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">scaling</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">SRCALPHA</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">pygame_rrdt_sampler_paint</span><span class="p">(</span><span class="n">sampler</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Visualisation function for rrdt sampler</span>

<span class="sd">    :param sampler: sampler to be visualised</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_color_transists</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">max_prob</span><span class="p">,</span> <span class="n">min_prob</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param value:</span>
<span class="sd">        :param max_prob:</span>
<span class="sd">        :param min_prob:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">denominator</span> <span class="o">=</span> <span class="n">max_prob</span> <span class="o">-</span> <span class="n">min_prob</span>
        <span class="k">if</span> <span class="n">denominator</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">denominator</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># prevent division by zero</span>
        <span class="k">return</span> <span class="mi">220</span> <span class="o">-</span> <span class="mi">180</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">value</span> <span class="o">-</span> <span class="n">min_prob</span><span class="p">)</span> <span class="o">/</span> <span class="n">denominator</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sampler</span><span class="o">.</span><span class="n">_last_prob</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">max_num</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">_last_prob</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">min_num</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">_last_prob</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">p_manager</span><span class="o">.</span><span class="n">particles</span><span class="p">):</span>
        <span class="n">sampler</span><span class="o">.</span><span class="n">particles_layer</span><span class="o">.</span><span class="n">fill</span><span class="p">((</span><span class="mi">255</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="c1"># get a transition from green to red</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">get_color_transists</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">_last_prob</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">max_num</span><span class="p">,</span> <span class="n">min_num</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span> <span class="mi">50</span><span class="p">)</span>
        <span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">sampler</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">draw_circle</span><span class="p">(</span>
            <span class="n">pos</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">colour</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="n">sampler</span><span class="o">.</span><span class="n">particles_layer</span>
        <span class="p">)</span>
        <span class="n">sampler</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">window</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">particles_layer</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">pygame_rrdt_planner_paint</span><span class="p">(</span><span class="n">planner</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">utils.common</span> <span class="kn">import</span> <span class="n">Colour</span>

    <span class="n">planner</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">path_layers</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">Colour</span><span class="o">.</span><span class="n">ALPHA_CK</span><span class="p">)</span>

    <span class="n">drawn_nodes_pairs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="c1"># Draw disjointed trees</span>
    <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">planner</span><span class="o">.</span><span class="n">_disjointed_trees</span><span class="p">:</span>
        <span class="n">bfs</span> <span class="o">=</span> <span class="n">BFS</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">validNodes</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">bfs</span><span class="o">.</span><span class="n">has_next</span><span class="p">():</span>
            <span class="n">newnode</span> <span class="o">=</span> <span class="n">bfs</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">newnode</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
                <span class="n">new_set</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">({</span><span class="n">newnode</span><span class="p">,</span> <span class="n">e</span><span class="p">})</span>
                <span class="k">if</span> <span class="n">new_set</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">drawn_nodes_pairs</span><span class="p">:</span>
                    <span class="n">drawn_nodes_pairs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_set</span><span class="p">)</span>
                    <span class="n">planner</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">draw_path</span><span class="p">(</span><span class="n">newnode</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
    <span class="c1"># Draw root tree</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">planner</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_set</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">({</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">})</span>
            <span class="k">if</span> <span class="n">new_set</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">drawn_nodes_pairs</span><span class="p">:</span>
                <span class="n">drawn_nodes_pairs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_set</span><span class="p">)</span>
                <span class="n">planner</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">draw_path</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">Colour</span><span class="o">.</span><span class="n">orange</span><span class="p">)</span>
    <span class="n">planner</span><span class="o">.</span><span class="n">visualiser</span><span class="o">.</span><span class="n">draw_solution_path</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">klampt_rrdt_planner_paint</span><span class="p">(</span><span class="n">planner</span><span class="p">):</span>
    <span class="n">drawn_nodes_pairs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">generate_random_colors</span><span class="p">():</span>
        <span class="kn">import</span> <span class="nn">colorsys</span>
        <span class="kn">import</span> <span class="nn">ghalton</span>

        <span class="n">perms</span> <span class="o">=</span> <span class="n">ghalton</span><span class="o">.</span><span class="n">EA_PERMS</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">sequencer</span> <span class="o">=</span> <span class="n">ghalton</span><span class="o">.</span><span class="n">GeneralizedHalton</span><span class="p">(</span><span class="n">perms</span><span class="p">)</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">sequencer</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">HSV_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">)</span>
            <span class="n">rgb_colour</span> <span class="o">=</span> <span class="n">colorsys</span><span class="o">.</span><span class="n">hsv_to_rgb</span><span class="p">(</span><span class="o">*</span><span class="n">HSV_tuple</span><span class="p">)</span>
            <span class="k">yield</span> <span class="p">(</span><span class="o">*</span><span class="n">rgb_colour</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>  <span class="c1"># add alpha channel</span>

    <span class="n">color_gen</span> <span class="o">=</span> <span class="n">generate_random_colors</span><span class="p">()</span>

    <span class="c1"># Draw disjointed trees</span>
    <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">planner</span><span class="o">.</span><span class="n">_disjointed_trees</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">color_gen</span><span class="p">)</span>
        <span class="c1"># draw nodes</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">planner</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">draw_node</span><span class="p">(</span>
                <span class="n">planner</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">cc</span><span class="o">.</span><span class="n">get_eef_world_pos</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">pos</span><span class="p">),</span> <span class="n">colour</span><span class="o">=</span><span class="n">c</span>
            <span class="p">)</span>
        <span class="c1"># draw edges</span>
        <span class="n">bfs</span> <span class="o">=</span> <span class="n">BFS</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">validNodes</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">bfs</span><span class="o">.</span><span class="n">has_next</span><span class="p">():</span>
            <span class="n">newnode</span> <span class="o">=</span> <span class="n">bfs</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">newnode</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
                <span class="n">new_set</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">({</span><span class="n">newnode</span><span class="p">,</span> <span class="n">e</span><span class="p">})</span>
                <span class="k">if</span> <span class="n">new_set</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">drawn_nodes_pairs</span><span class="p">:</span>
                    <span class="n">drawn_nodes_pairs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_set</span><span class="p">)</span>

                    <span class="n">planner</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">draw_path</span><span class="p">(</span>
                        <span class="n">planner</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">cc</span><span class="o">.</span><span class="n">get_eef_world_pos</span><span class="p">(</span><span class="n">newnode</span><span class="o">.</span><span class="n">pos</span><span class="p">),</span>
                        <span class="n">planner</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">cc</span><span class="o">.</span><span class="n">get_eef_world_pos</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">pos</span><span class="p">),</span>
                        <span class="n">colour</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
                    <span class="p">)</span>
    <span class="c1"># Draw root tree</span>
    <span class="n">c</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">color_gen</span><span class="p">)</span>
    <span class="c1"># override to red</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># draw nodes</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">planner</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
        <span class="n">planner</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">draw_node</span><span class="p">(</span>
            <span class="n">planner</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">cc</span><span class="o">.</span><span class="n">get_eef_world_pos</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">pos</span><span class="p">),</span> <span class="n">colour</span><span class="o">=</span><span class="n">c</span>
        <span class="p">)</span>
    <span class="c1"># draw edges</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">planner</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_set</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">({</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">})</span>
            <span class="k">if</span> <span class="n">new_set</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">drawn_nodes_pairs</span><span class="p">:</span>
                <span class="n">drawn_nodes_pairs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_set</span><span class="p">)</span>
                <span class="n">planner</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">draw_path</span><span class="p">(</span>
                    <span class="n">planner</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">cc</span><span class="o">.</span><span class="n">get_eef_world_pos</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">pos</span><span class="p">),</span>
                    <span class="n">planner</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">cc</span><span class="o">.</span><span class="n">get_eef_world_pos</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">pos</span><span class="p">),</span>
                    <span class="n">colour</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
                <span class="p">)</span>


<span class="c1"># start register</span>
<span class="n">sampler_id</span> <span class="o">=</span> <span class="s2">&quot;rrdt_sampler&quot;</span>

<span class="n">planner_registry</span><span class="o">.</span><span class="n">register_sampler</span><span class="p">(</span>
    <span class="n">sampler_id</span><span class="p">,</span>
    <span class="n">sampler_class</span><span class="o">=</span><span class="n">RRdTSampler</span><span class="p">,</span>
    <span class="n">visualise_pygame_paint</span><span class="o">=</span><span class="n">pygame_rrdt_sampler_paint</span><span class="p">,</span>
    <span class="n">visualise_pygame_paint_init</span><span class="o">=</span><span class="n">pygame_rrdt_sampler_paint_init</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">planner_registry</span><span class="o">.</span><span class="n">register_planner</span><span class="p">(</span>
    <span class="s2">&quot;rrdt&quot;</span><span class="p">,</span>
    <span class="n">planner_class</span><span class="o">=</span><span class="n">RRdTPlanner</span><span class="p">,</span>
    <span class="n">visualise_pygame_paint</span><span class="o">=</span><span class="n">pygame_rrdt_planner_paint</span><span class="p">,</span>
    <span class="n">visualise_klampt_paint</span><span class="o">=</span><span class="n">klampt_rrdt_planner_paint</span><span class="p">,</span>
    <span class="n">sampler_id</span><span class="o">=</span><span class="n">sampler_id</span><span class="p">,</span>
<span class="p">)</span>
<span class="c1"># finish register</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Tin Lai.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>